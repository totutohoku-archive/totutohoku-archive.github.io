<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta charset="UTF-8">
<META name="GENERATOR" content="IBM HomePage Builder 2001 V5.0.0 for Windows">
<title>暗号ソフトをデザインしてみる</title>
</head>

<BODY background="1052.gif" bgcolor="#ffffff" text="#000000">

<p align="center"><FONT color="#0000FF" size="6"><STRONG>暗号ソフトをデザインしてみる</STRONG></FONT></p>
<P><BR>
書きかけ＆試論、まだ知識不足なので間違っているところもあるかも。<BR>
この分野に詳しい人はぜひ<A href="mailto:totutohoku@hotmail.com"><U><FONT color="#0000FF">アドバイスをください</FONT></U></A>。<BR>
<BR><BR>
<FONT size="+1"><B>暗号システムの概観の構築</B></FONT><BR><BR>
周期の長い擬似乱数を、擬似バーナム暗号の乱数表に見立てる。<BR>
乱数を「完全にランダムに」取り、それを擬似乱数の種として秘密鍵とする。<BR>
バーナム暗号の鍵を、公開鍵暗号RSAを用いて暗号化する。<BR>
バーナム暗号の種の一部は、ユーザが指定する鍵にできる。<BR>
<BR>
利点：<BR>
バーナム暗号の性質から、高速性が期待できる。<BR>
全体としては公開鍵暗号の性質を持たせるため、公開鍵暗号特有の利点がある。<BR>
<BR>
※<BR>
擬似バーナム暗号（勝手にそう呼んでいる）とは、真の乱数表を使うのではなく、巨大な乱数表のうち「どの部分を使うか」を鍵として暗号法とする方法である。<BR>
乱数表とのXORによって構成され、乱数表は基本的に再利用されないという点は同じだが、いくつかの重要な概念においてバーナム暗号と違うので注意。<BR>
<BR>
注意点：<BR>
周期の長い良い擬似乱数が必要。<BR>
擬似バーナム暗号ゆえに、原文-暗号文のXOR一致攻撃に対する考察または対策が必要。<BR>
種をランダムに選ぶための工夫が必要。<BR>
<BR>
<BR>
<B><FONT size="+1">暗号アルゴリズム</FONT></B><BR>
<BR>
・本文の暗号化<BR>
乱数発生ルーチンMersenne Twister + ハッシュSHA1
による(擬似)バーナム暗号。<BR>
<BR>
・共有鍵の暗号化<BR>
RSA暗号。<BR>
<BR>
<BR>
<B><FONT size="+1">強度を見積もる</FONT></B><BR>
<BR>
<B>基礎的な要素</B><BR>
<BR>
<FONT color="#000000">擬似乱数Mersenne Twister（MT） の周期は 2^19937-1
通り。<BR>
RSA暗号のビット長は2048以上の長いものが使用できる。</FONT><BR>
<BR>
擬似乱数MTは優れた性質を持つ乱数列を出力することが示されているので、これは取りあえず「2^19937-1周期内でランダムなもの」と言って良い。<BR>
そもそも、周期性・部分的周期性にさえ気をつければ、バーナム暗号の性質上、少々1が出やすかったりしても大丈夫だ（エントロピー低下は少ない）。<BR><BR>
<BR>
<B>擬似バーナム暗号特有のクラックに対する強度（1）</B><BR>
<BR>
ただ、原文-暗号文（の既知の一部）のXORから、バーナム暗号のビット列の一部がわかることに対する警戒をせねばならない。<BR>
本来バーナム暗号の乱数列は「完全にランダムで再現性なし」なのだが、ここでは擬似バーナム暗号なので、「乱数表」と使われた乱数列の一部がわかると、その後の乱数列が予測できてしまう危険があるのだ。<BR><BR>
原文のうちｎビットが既知であり暗号文も知られている時、バーナム暗号の乱数列のうちｎビットの部分列が知られる（以後このｎビットの並びを、盗聴部分列と呼ぶ）。<BR>
この場合の安全性を考えてみよう（今後、大きな値を考えている場合の-1などの小さな誤差は、全て無視する）。<BR>
<BR>
最も安全な場合を考える。盗聴部分列の形の特性から（後述）、MTのビット列の中に含まれる個数期待値が最も多くなる場合（つまりMTの乱数表の位置が最も推定されにくくなる場合）である。<BR>
この場合、2^19937通りの中から「nビット部分列」を取り出す取り出し方は、<BR>
2^19937-n　通り<BR>
ある（これはほとんど2^19937に近い値である）。<BR>
したがって、盗聴部分列ｎと同じ並びのビット列が、この全ての取り出し方の中にたまたま見出される個数の期待値は、<BR>
2＾19937／2^n　　・・・式１）<BR>
程度と概算できる。<BR>
つまり、盗聴部分列がMTのうちのどの部分であるかが、2^（19937-n）通りにまで絞られることになる。<BR>
例えばn=20000（2.5キロバイト）程度だとすると、このようなビット列はMT中に他にたくさんあるというよりはむしろほとんどないと思われる。<BR><BR>
盗聴部分列の形の特性によっては、これよりも位置を特定される可能性が高くなる場合もある。<BR>
次のように考えるとわかりやすい。<BR>
盗聴部分列が「0101」であったとすると、MTのビット列「010101」の中にこの部分列は2つ存在することができるが、盗聴部分列が「0011」であったとすると、MTの6ビットの部分列の中にこれを2つ含ませることができない。2つ含ませるためには、「00110011」という8ビットの並びが必要である。<BR>
先に考えた「最も安全な場合」とは、重複を全て許した場合の概算であった。<BR>
重複が許されるとは、盗聴部分列と同じビット列が、MT中により多く含まれ得るということであり、つまり、乱数表の位置が特定されにくいということである。<BR>
ビットの重複が一切許されない時には（そうした形が実際にあるのか、それはどんな形なのかは考えずに）、ｎビットの盗聴部分列は、MTのビット列中に　<BR>
2^19937／2^n<BR>
個程度含まれると概算できる。<BR>
ところが、これは安全な場合と大差ない（式１と同じ）。<BR>
この暗号法の強度は、盗聴部分列の形の特性には依存しない。<BR><BR><BR>
<B>擬似バーナム暗号特有のクラックに対する強度（2）</B><BR>
<BR>
では仮に、n=20000程度で盗聴部分列が知られ、そのために理論上はMTビット列上の「位置」が知られ得るとしよう。<BR>
MTビット列の、それ以後のビット列と暗号文とのXORを取れば、暗号文は解読される。<BR>
たった20000ビットの一致から、擬似バーナム暗号は非力になってしまうのだろうか？<BR>
<BR>
2^19937（およそ4.3×10^6000）という周期内で、20000ビットの部分列が「一致する」ような部分を見つけるのに要する計算時間を考える。<BR>
非常に高速な、あるいは並列処理のコンピュータを用意し、1秒に10^500回の「20000ビット一致演算」を行うことができるとする（世界中の全てのコンピュータを合わせても不可能なほどだが）。<BR>
1年は3.2×10^7秒なので、これを用いて1年に3.2×10^508回の演算が可能である。この回数の「比較」を行ったときにMTビット列から盗聴部分列を発見できる確率は<BR>
1　÷　（4.3×10^6000/3.2×10^508）　=~　１　÷　（1.34×10^5500）<BR>
である。<BR>
宇宙の寿命より遥かに長い時間をかけても、MTビット列上に唯一あるとわかっているビット列が、どの部分にあるかを検索することは「不可能」である。<BR>
<BR>
原文-暗号文のXORを取ってビット列を得る方法は、例えば2^32周期のrand()のような擬似乱数に対しては強力な盗聴法であるが、MTの長い長い周期の擬似乱数に対しては効果的ではない。<BR>
<BR><BR>
<B>MT擬似乱数の性質による脆弱さへの対処</B><BR>
<BR>
MTの理論を構築された京都大学総合人間学部の松本先生のお話によると<BR>
「<BR>
この生成法は、計算量理論的に安全な乱数をそのままでは生成しません。しかし、Secure
Hashing Algorithm（数ワードを圧縮して１ワードを生成する、非可逆的なアルゴリズム）と組み合わせれば使えます。
つまり、従来存在した、線形疑似乱数（GFSRなど）+SHAの、GFSRの代わりにMTを使うことは有効で、すでにそれを実施しているinternet関連の企業があります。
<BR>
」（webページより引用）<BR>
とのこと。<BR>
上述の概算から考えて、なぜ計算量理論的に危険なのかちょっとわからないのだが、何らかの性質から、乱数表の位置候補が一気に絞り込まれるような場合があるのだろうか？<BR>
あいにくMT擬似乱数は数学的な多くの背景を持っていて、私にはわからない・・・。<BR>
ひょっとすると、1が100個連続するようなことがMTの方法では非常に稀で、MTの性質を熟知した人間ならそのようなビット列の位置を知っている、というような意味かもしれない。<BR>
松本先生はご自分で「この（暗号の）方面には詳しくないので・・・」とご謙遜なさっているが、まあ、ハッシュを使った方が良いと言うのだから恐らく実際にそうなのだろう、素直に従おう（笑）。<BR><BR>
ハッシュは一方向計算（不可逆）だから、乱数列にこれを適用する場合、ビット列がａ→ｂと減るとすると暗号上は次のような意味を持つ。<BR>
「既知のハッシュｂビットに対応する元ａビットを特定することが困難で、また対応するａビットの乱数列候補が複数存在する」<BR>
<BR>
ハッシュのｂビットからａビットを推測することは非常に難しい。<BR>
つまり、ａビット列をいくつも用意してハッシュしてみてｂに一致することを確かめなければならない。<BR>
例えば、ａが1024だとすると、ａビット列の可能な組み合わせを全て試すのには、2^1024回の演算が必要になる。<BR>
この計算回数は、盗聴者にとってほとんど絶望的だ。<BR>
2^1024回の演算を（何らかの？方法で）こなし、乱数ビット列のaビット列をいくつかの（2＾b通りの）可能性に絞れたとしても、今度はそれを乱数表と照らし合わせて位置を特定する必要がある。<BR>
これにかかる莫大な時間は前述した通りである。<BR>
<BR>
このようなことを考えると、確かにハッシュを使うことで暗号が堅牢になることは間違いない。<BR>
ただ、「この程度の」計算量の増加が、MTの長い周期性による安全性に対して影響を及ぼすとは考えにくい。<BR>
ハッシュはやはり、何らかのMT擬似乱数自体の「性質」を隠すためなのだろうか・・・（先ほど述べた「100個連続する1の位置が既知」のような？）。<BR>
そうであるとすれば、このハッシュ一致にかかる計算時間は、この暗号全体の安全性にダイレクトにかかわることになる。<BR>
その場合、ａを多めに取る必要がある。せっかくMTが　2^19937　という莫大な計算量的安全性を用意してくれているのだから、ハッシュが32ビットではあまりにも淋しい。<BR>
ハッシュ長を長くすると暗号化に要する時間も長くなってしまうので、実用性も考えて、1024ビット程度のMT乱数列から8ビットの「暗号化用乱数列」を生成することにしようか。<BR>
盗聴者は16ビット分の「暗号化用乱数列」を突き止めた場合、真の乱数ビット列を得るために　2^2048　回の演算を行う必要がある。<BR>
わずか日本語１文字分の乱数列一致（そのような乱数ビット列は、MTの中に2^19937通りもある）という、暗号にとってあまり重要であると思えない情報のために　2^2048　回の演算を行う必要があることは、盗聴者にとって悲劇的な事実であるに違いない。<BR>
<BR><BR>
<B>秘密鍵暗号部分の、攻撃に対する耐性</B><BR>
<BR>
・「乱数列が未知」である限り、バーナム暗号なので解読は理論的に絶対不可能。<BR>
・乱数列の特定をすること（例えばXORによる乱数列の位置推測）は、上記のように計算量的に困難。<BR>
・ブルートフォースアタックは上記のように計算量的に困難。<BR>
<BR>
<BR>
<B><FONT size="+1">ランダムな秘密鍵をどのように作るか</FONT></B><BR><BR>
<A href="hdrand.html"><U><FONT color="#0000FF">こちらを参照。</FONT></U></A><BR><BR>
<BR>
<B><FONT size="+1">公開鍵暗号にする</FONT></B><BR>
<BR>
秘密鍵暗号部分はこれで完成。<BR>
また、バーナム暗号の種の全ビットをランダムに取るだけでなく、一部のビットはユーザが鍵として与えることもできる。<BR>
こうすることで、万一「ランダムな秘密鍵発生部分」に問題が生じても、なおバーナム暗号の安全性を保つことができる。<BR>
<BR>
次に公開鍵暗号RSAを用いて、秘密鍵自体を暗号化する。<BR>
せっかく秘密鍵部分を堅牢に作っているのだから、RSA部分の鍵ビット長が512ビットでは辛い。<BR>
幸い、RSAのアルゴリズムは難しくなく、また秘密鍵の鍵長（19937ビット＝2.5KB弱）程度の暗号化のためには大した時間もかからないので、長い鍵長にも対応できるようにしておく。<BR>
ユーザは必要に応じて鍵長を変更できる。ドシロウトが集まっただけの部署で実用するなら鍵長9ビット（笑）でも非常に安全であろう。<BR><BR><BR>
<B><FONT size="+1">この暗号システムのメリット</FONT></B><BR>
<BR>
バーナム暗号の鍵をランダムに生成する意味はどこにあるのかと問われるかもしれない。<BR>
それもユーザが鍵として使えば、より強力な秘密鍵暗号になるのではないか？<BR>
また、とってつけたように公開鍵暗号にするのはどういうわけか？<BR>
<BR>
バーナム鍵をランダムに作れることには、２つのメリットがある。<BR>
１つは、ユーザ指定の固定した鍵を用いる場合、もしバーナム鍵が盗聴者に知られてしまった場合、同じ鍵を使った他の文書も解読されてしまうという危険を防止できること。<BR>
さらにもう一つは、この方式にすることで、<B>「秘密鍵を作成する必要がある人」が直接秘密鍵を入力する必要がなくなる</B>こと。<BR>
例えば、他のコンピュータ上で自動的に生成された文章を安全に自分のコンピュータに送りたい場合を考えるといい。<BR>
暗号化のための鍵を別のコンピュータにそのまま置いておくわけにはいかないだろう。<BR>
ところがコンピュータがバーナム暗号の秘密鍵を自動生成し、RSAの公開鍵を用いて秘密鍵を暗号化したものを送ることで、自分だけがその暗号を解読できることになる。<BR>
そして、バーナム暗号のエンコード・デコードコストは、RSA暗号よりもずっと小さい。<BR>
<BR>
もちろん、バーナム暗号の鍵の一部（一部といっても例えば1024bitを超えるようなものも可能だろう、何しろMTの周期は2^19937だから）をユーザが直接指定することもできる。<BR>
その部分は、暗号文に付加される「RSA暗号で暗号化された鍵」から除くことで、強度1024bitを超える秘密鍵暗号としても使える。<BR>
<BR>
<BR>
<FONT size="+1"><B>シロウトが作る暗号の問題</B></FONT><BR><BR>
よく言われることだが、暗号（理論）は自作しない方がいい（既存の暗号理論を組み合わせた、暗号ソフトの自作は別だが）。<BR>
暗号理論は高度な数学的要素が複雑に絡み合っている。世界の最先端を行く研究と自分のささいなヒラメキごときとは2^1024どころではない開きがあることをいつも肝に銘じておきたい（これも自戒）。<BR>
<BR>
「XORとrandom()を複雑に絡み合わせればそうそう解けないだろう」というのは、スキルのある人をあまりにも甘く見すぎだ。<BR>
例えば暗号化されたファイルがWindowsのexeファイルだと知っていれば、通常、ファイルの前半の数文字は知ることができる（少なくともある程度の予想が可能である）。<BR>
そして、たった4バイトわかれば、random()の乱数列のうち開始点がほとんど一意に定まるのだ。<BR>
<BR>
多くのWindowsのexeファイルは、先頭に<BR>
4D 5A ・・・ 6D 6F 64 65 2E（0～117バイト）　～～cannot
be run in DOS mode.<BR>
4D 5A ・・・ 57 69 6E 33 32（0～116バイト）　～～must
be run under Win32<BR>
こういったようなデータの並びがあるので、4バイト一致を見出すことは困難ではない。<BR>
<BR>
もちろん、前回の数字とXORを取ったり、random()から得られる乱数を間引いたりすることで少々の混乱を招くことはできるだろうが、暗号化されたファイルの数ビットだけを変化させた暗号文’をいくつか用意して暗号文-復号文の対応をいくつも用意すれば、その規則性がばれるのも時間の問題だろう。<BR>
世界のトップにはDESを2日で解読するプロフェッショナルがいる。<BR>
アルゴリズムを見られたらほとんど即座に解読できるような暗号は、現代の暗号分野では全く通用しないことをよく覚えておく必要がある。<BR><BR><br>
<B><FONT size="+1">展望</FONT></B><BR>
<BR>
BlockSorting＋PPMの自作圧縮ルーチン、またはDeepFreezerなどの優秀な圧縮ソフト（アルゴリズム）と組み合わせることで、圧縮+暗号化（いずれも高機能）の機能を持たせる。<BR>
末端のユーザは優秀な暗号化ツールを求めてはいないが、優秀な圧縮ツールなら需要がある。<BR>
高圧縮で強力な暗号機能を持った手軽な日本語ツールがない（法律の問題もあるのかも）。<BR>
フォルダ全体の圧縮・解凍（+暗号化）機能などユーザビリティを高め、解凍＋デコード用dllを用意すれば広く使われる可能性も出てくる。<BR>
<br>
<br>
<br>
<br>
<br>
<br>
</P>
</BODY>
</html>
